// Note: will be capitalizing the comments for crucial and necessary lines of code or functions, CTRL+F and type !!  to find
import express from "express"; // !! IMPORT express TO USE express METHODS, MAKE SURE TO INSTALL express
import cors from "cors"; // !! IMPORT cors MIDDLEWARE, MAKE SURE TO INSTALL cors
import bodyParser from "body-parser"; // !! IMPORT bodyParser TO READ AND MAKE POST REQUESTS (anything w req.body), MAKE SURE TO INSTALL body-parser
import pgPromise from "pg-promise"; // !! IMPORT pgPromise TO CONNECT TO SQL DATABASE, MAKE SURE TO INSTALL pg-promise
// !! MAKE SURE TO INSTALL nodemon --save-dev

// !! MAKES AN INSTANCE OF pgPromise(), STORE IN VARIABLE NAMED pgp
const pgp = pgPromise();
// !! CONNECTS TO THE LOCATION OF THE SQL DATABASE, eventonica IS THE DATABASE NAME, STORE IN VARIABLE CALLED db (database)
const db = pgp("postgres://localhost:5432/eventonica");

// !! MAKES AN INSTANCE OF express(), STORE IN VARIABLE NAMED app
const app = express();
// !! SET THE PORT TO A DESIRED NUMBER
const PORT = 4000;

// !! USE cors() MIDDLEWARE
app.use(cors());

// !! USE bodyParser.urlencoded() AND bodyParser.json() MIDDLEWARE TO PARSE req.body POST REQUESTS
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

// !! ROUTES TO "http://localhost:PORT/users", GET REQUEST
app.get("/users", async function (req, res, next) {
  try {
    const users = await db.any("SELECT * FROM users ORDER BY id", [true]); // !! SELECT ALL THE ENTRIES IN users TABLE ORDERED BY ID
    res.send(users); // !! SEND TO THE ROUTE
  } catch (e) {
    // !! CATCH THE ERROR IF TRY DOESN'T WORK
    return res.status(400).json({ e }); // !! SEND THE ERROR TO THE ROUTE
  }
});

// sorts the users table by id
app.get("/users/sortedId", async function (req, res, next) {
  try {
    const users = await db.any("SELECT * FROM users ORDER BY id", [true]);
    res.send(users);
  } catch (e) {
    return res.status(400).json({ e });
  }
});

// sorts the users table by name
app.get("/users/sortedName", async function (req, res, next) {
  try {
    const users = await db.any("SELECT * FROM users ORDER BY name", [true]);
    res.send(users);
  } catch (e) {
    return res.status(400).json({ e });
  }
});

// !! ROUTES TO "http://localhost:PORT/users", POST REQUEST
app.post("/users", async (req, res) => {
  const user = {
    name: req.body.name, // !! GRABS VALUE FROM THE POST REQUEST, WE'RE POSTING newUser WHICH IS {name: "", email: ""}, TAKES THE .name
    email: req.body.email, // !! GRABS VALUE FROM THE POST REQUEST, WE'RE POSTING newUser WHICH IS {name: "", email: ""}, TAKES THE .email
  };
  console.log("post", user);
  try {
    const users = await db.any("SELECT * FROM users", [true]); // selects all the users
    console.log("database", users);
    if (users.length === 0) {
      // if there are no users in the database
      db.any("ALTER SEQUENCE users_id_seq RESTART WITH 1"); // have the autogenerated id's start at 1
    }
    const createdUser = await db.one(
      "INSERT INTO users(name, email) VALUES($1, $2) RETURNING *", // !! INSERT VALUE FROM POST REQUEST INTO DATABASE
      [user.name, user.email] // !! THESE VALUES CORRESPOND WITH THE $ VALUES, $1 = user.name, $2 = user.email
    );
    console.log("createdUser, post", createdUser);
    res.send(createdUser); // !! SEND THE INSERTED VALUE TO THE BACK END SO FRONT END CAN ACCESS WITH FETCH
  } catch (e) {
    return res.status(400).json({ e }); // !! CATCHES AND PRINTS THE ERROR
  }
});

// edits a user specified by id
app.put("/users/:id", async (req, res) => {
  // : acts as a placeholder
  const userId = req.params.id;
  console.log(userId);
  const user = {
    name: req.body.name,
    email: req.body.email,
  };
  console.log("put", user);
  try {
    await db.many("UPDATE users SET name=$1, email=$2 WHERE id=$3", [
      user.name,
      user.email,
      userId,
    ]);
    res.send({ status: "success" });
  } catch (e) {
    return res.status(400).json({ e });
  }
});

// a unique route for each user dependent on id
app.get("/users/:id", async function (req, res, next) {
  const userId = req.params.id;
  console.log(userId);
  try {
    await db.many("SELECT FROM users WHERE id=$1", [userId]);
    res.send({ status: "success" });
  } catch (e) {
    return res.status(400).json({ e });
  }
});

// !! ROUTES TO "http://localhost:PORT/users/whatevertheIDis"; DELETE A USER BY ID
app.delete("/users/:id", async (req, res) => {
  // : acts as a placeholder
  const userId = req.params.id; // !! GRABS THE ID SPECIFIED IN THE DELETE REQUEST MADE IN FRONTEND
  console.log(userId);
  try {
    await db.many("DELETE FROM users WHERE id=$1", [userId]); // !! DELETE THE SPECIFIED USER, $1 = userId
    res.send({ status: "success" }); // !! SEND SUCCESS WHEN THE USER HAS BEEN DELETED
  } catch (e) {
    return res.status(400).json({ e }); // !! CATCHES AND PRINTS THE ERROR
  }
});

// !! ROUTES TO "http://localhost:PORT/events", GET REQUEST
app.get("/events", async function (req, res, next) {
  try {
    const events = await db.any("SELECT * FROM events ORDER BY id", [true]); // !! SELECT ALL THE ENTRIES IN events TABLE ORDERED BY ID
    res.send(events); // !! SEND TO THE ROUTE
  } catch (e) {
    // !! CATCH THE ERROR IF TRY DOESN'T WORK
    return res.status(400).json({ e }); // !! SEND THE ERROR TO THE ROUTE
  }
});

// sorts the events table by id
app.get("/events/sortedId", async function (req, res, next) {
  try {
    const events = await db.any("SELECT * FROM events ORDER BY id", [true]);
    res.send(events);
  } catch (e) {
    return res.status(400).json({ e });
  }
});

// sorts the events table by date
app.get("/events/sortedDate", async function (req, res, next) {
  try {
    const events = await db.any("SELECT * FROM events ORDER BY date", [true]);
    res.send(events);
  } catch (e) {
    return res.status(400).json({ e });
  }
});

// sorts the events table by name
app.get("/events/sortedName", async function (req, res, next) {
  try {
    const events = await db.any("SELECT * FROM events ORDER BY name", [true]);
    res.send(events);
  } catch (e) {
    return res.status(400).json({ e });
  }
});

// sorts the events table by category
app.get("/events/sortedCategory", async function (req, res, next) {
  try {
    const events = await db.any("SELECT * FROM events ORDER BY category", [
      true,
    ]);
    res.send(events);
  } catch (e) {
    return res.status(400).json({ e });
  }
});

// !! ROUTES TO "http://localhost:PORT/events", POST REQUEST
app.post("/events", async (req, res) => {
  // !! GRABS VALUE FROM THE POST REQUEST, WE'RE POSTING state/newEvent WHICH IS {eventName: "", date: "", description: "", category: ""},
  const event = {
    name: req.body.eventName,
    date: req.body.date,
    description: req.body.description,
    category: req.body.category,
  };
  console.log(event);
  try {
    const events = await db.any("SELECT * FROM events", [true]); // selects all the events
    console.log("database", events);
    if (events.length === 0) {
      // if there are no events in the database
      db.any("ALTER SEQUENCE events_id_seq RESTART WITH 1"); // have the autogenerated id's start at 1
    }
    const createdEvent = await db.one(
      "INSERT INTO events(name, date, description, category) VALUES($1, $2, $3, $3) RETURNING *", // !! INSERT VALUE FROM POST REQUEST INTO DATABASE
      [event.name, event.date, event.description, event.category] // !! THESE VALUES CORRESPOND WITH THE $ VALUES, $1 = event.name, $2 = event.date, etc
    );
    console.log("createdEvent, post", createdEvent);
    res.send(createdEvent); // !! SEND THE INSERTED VALUE TO THE BACK END SO FRONT END CAN ACCESS WITH FETCH
  } catch (e) {
    return res.status(400).json({ e }); // !! CATCHES AND PRINTS THE ERROR
  }
});

// !! ROUTES TO "http://localhost:PORT/events/whatevertheIDis"; DELETE AN EVENT BY ID
app.delete("/events/:id", async (req, res) => {
  // : acts as a placeholder
  const eventId = req.params.id; // !! GRABS THE ID SPECIFIED IN THE DELETE REQUEST MADE IN FRONTEND
  console.log(eventId);
  try {
    await db.many("DELETE FROM events WHERE id=$1", [eventId]); // !! DELETE THE SPECIFIED EVENT, $1 = eventId
    res.send({ status: "success" }); // !! SEND SUCCESS WHEN THE EVENT HAS BEEN DELETED
  } catch (e) {
    return res.status(400).json({ e }); // !! CATCHES AND PRINTS THE ERROR
  }
});

// checks if the server is working properly, this statement should print in the console/terminal
app.listen(PORT, () => console.log(`Hello, I am listening on port ${PORT}.`));
